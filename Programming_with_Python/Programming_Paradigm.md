# Programming Paradigm
A programming paradigm is a fundamental style or approach to programming that dictates how programmer organize and structure code to solve problem.


**Types of Programming Paradigms**

1. **Imperative Programming Paradigms:** A programming paradigm that focuses on describing a sequence of step to achieve a specific goal or perform a task.

2. **Declarative Programming Paradigms:** A programming paradigms that emphasizes describing “what” a program should accomplish, rather than specifying “how” to achieve it through a sequence of detailed steps. 


**Types of Imperative Programming Paradigms**
Imperative programming divided into three broader categories; these paradigms are as followings:

1. **Procedural Programing Paradigms**
Procedural programming is a programming paradigm or style that focuses on writing code as a series of procedure or functions.

2. **Object Oriented Paradigms**
In this paradigm, a program is designed and structured as collection of objects, each of which represents a real world entity or concept.

3. **Parallel Processing Approach**
Parallel processing is an approach to computing where multiple tasks or processes are executed simultaneously.



**Types of Declarative Programming Paradigms**
Declarative Programming Paradigms have been divided into three broader categories; these paradigms are as following:

1. **Logical Programming Paradigms**
Logical programming is a programming paradigm that is based on formal logic and mathematical reasoning.

2. **Functional Programming Paradigms**
Functional programming is a programming paradigm that treats computation as the evaluation of mathematic functions and avoid changing states and mutable data.

3. **Database Processing Approach**
Database processing, often referred to as database management or data processing, is the systematic approach to storing, retrieving, manipulating and managing the data with in a database.

**Purpose of a Programming Model**
The main purpose of a programming model is structuring your code. That structure makes it easier to update the code and create new functionality within the code.

**Procedural Programing Paradigms**
Procedural programming is a programming paradigm or style that focuses on writing code as a series of procedure or functions.

**Advantages of Procedural Programming**
1. Easy to learn
2. Reusable
3. Easy to understand

**Disadvantages of Procedural Programming**
1. Hard to maintain
2. Does not relate well
3. Exposed data

_Programming Principle for reducing the duplication = “DRY  (Don’t Repeat Yourself)”_

**Best Way To Inspect The Code**
Inspecting code is a crucial aspect of software development. Here are some key points for effective code inspection:

1. **Read Methodically:** Examine the code line by line, noting variable and function names, and use syntax highlighting and formatting tools.
2. **Take Notes:** Make notes on your observations, questions, and understanding of the code's purpose.
3. **Understand Algorithms:** Comprehend the code's logic and algorithms, possibly using diagrams or pseudocode.
4. **Error Handling:** Check for error handling, exceptions, and clear error messages.
5. **Review Documentation:** Ensure comments and external documentation accurately describe the code.
6. **Data Flow:** Trace how data moves through the code to understand data manipulation.
7. **Testing and Debugging:** Use testing and debugging tools to verify code behavior.
8. **Follow Coding Standards:** Adhere to coding standards and conventions.
9. **Peer Reviews:** Collaborate with peers for code reviews, leveraging code review tools.
10. **Refactoring:** Consider refactoring for clarity and readability.
11. **Code Analysis Tools:** Use static code analysis tools to identify issues automatically.
12. **Learn Domain:** Understand domain-specific code by learning domain concepts.
13. **Seek Expert Help:** Consult experts for challenging or unfamiliar code sections.
14. **Iterate:** Code inspection is an iterative process to gain a deeper understanding and improve code quality and maintainability.

## Algorithm
An algorithm is a step-by-step, systematic set of instruction or well-defined computational procedure that takes an input or set of inputs and produce desired output or result. 

1. **Recursion**
Recursion refers to a method or a function that will call itself. It is used to resolve problem by breaking the problem down into sub problem.

2. **Divided and conquer**
This consists of two parts. The first is breaking the problem into sub problems and the second is solving the final solution.

3. **Dynamic programming**
This is mainly used for optimization problems. It is similar to the divide and conquer algorithm in that it splits the problems into sub problems.

4. **Greedy algorithms**
This one finds the best solution in each and every step instead of approaching optimization in a global way.

**Refactoring**
Refactoring is the process of refactoring the existing code or software to improve its internal structure

**Algorithm Complexity**
Algorithmic complexity is a measure of the time or resources required for an algorithm to complete its task based on the size of the input, often denoted as 'n', which represents the number of elements. Algorithmic complexity can be categorized into two main types.

1. **Time Complexity**: Time complexity is a measure of the computational or execution time required by an algorithm to solve a problem based on the size of the input.

2. **Space Complexity**: Space complexity refers to the amount of memory or storage space required by an algorithm to perform its task based on the size of the input.

## Big O Notation
Big O Notation is the most fundamental tool to measure the cost of an algorithm. It describes the complexity of the code using algebraic terms.

1. **Constant:** The algorithm takes the same amount of time to run regardless of the size of its input.

2. **Logarithmic:** The algorithm's runtime grows logarithmically with the size of its input.

3. **Linear:** The algorithm's runtime grows linearly with the size of its input.

4. **Quadratic:** This means that the algorithm's performance increases quadratically as the input size 'n' grows. 

5. **Cubic:** This means that the algorithm's runtime or resource usage grows cubically as the input size 'n' increases. 

6. **Exponential:** This means that the algorithm's performance deteriorates significantly as the input size 'n' increases. 

7. **Factorial:** This is the most inefficient time complexity, where the algorithm's performance grows factorially with the input size 'n.' 
