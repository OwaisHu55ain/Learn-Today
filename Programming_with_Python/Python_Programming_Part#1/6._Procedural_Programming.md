# Procedural Programing Paradigms
Procedural programming is a programming paradigm or style that focuses on writing code as a series of procedure or functions.

**Advantages of Procedural Programming**
1. Easy to learn
2. Reusable
3. Easy to understand

**Disadvantages of Procedural Programming**
1. Hard to maintain
2. Does not relate well
3. Exposed data

_Programming Principle for reducing the duplication = “DRY  (Don’t Repeat Yourself)”_

## Best Way To Inspect The Code
Inspecting code is a crucial aspect of software development. Here are some key points for effective code inspection:


1. **Read Methodically:** Examine the code line by line, noting variable and function names, and use syntax highlighting and formatting tools.

2. **Take Notes:** Make notes on your observations, questions, and understanding of the code's purpose.

3. **Understand Algorithms:** Comprehend the code's logic and algorithms, possibly using diagrams or pseudocode.

4. **Error Handling:** Check for error handling, exceptions, and clear error messages.

5. **Review Documentation:** Ensure comments and external documentation accurately describe the code.

6. **Data Flow:** Trace how data moves through the code to understand data manipulation.

7. **Testing and Debugging:** Use testing and debugging tools to verify code behavior.

8. **Follow Coding Standards:** Adhere to coding standards and conventions.

9. **Peer Reviews:** Collaborate with peers for code reviews, leveraging code review tools.

10. **Refactoring:** Consider refactoring for clarity and readability.

11. **Code Analysis Tools:** Use static code analysis tools to identify issues automatically.

12. **Learn Domain:** Understand domain-specific code by learning domain concepts.

13. **Seek Expert Help:** Consult experts for challenging or unfamiliar code sections.

14. **Iterate:** Code inspection is an iterative process to gain a deeper understanding and improve code quality and maintainability.


## Algorithm
An algorithm is a step-by-step, systematic set of instruction or well-defined computational procedure that takes an input or set of inputs and produce desired output or result. 

1. **Recursion**
Recursion refers to a method or a function that will call itself. It is used to resolve problem by breaking the problem down into sub problem.

2. **Divided and conquer**
This consists of two parts. The first is breaking the problem into sub problems and the second is solving the final solution.

3. **Dynamic programming**
This is mainly used for optimization problems. It is similar to the divide and conquer algorithm in that it splits the problems into sub problems.

4. **Greedy algorithms**
This one finds the best solution in each and every step instead of approaching optimization in a global way.


## Algorithm Complexity
Algorithmic complexity is a measure of the time or resources required for an algorithm to complete its task based on the size of the input, often denoted as 'n', which represents the number of elements. Algorithmic complexity can be categorized into two main types.

1. **Time Complexity**: Time complexity is a measure of the computational or execution time required by an algorithm to solve a problem based on the size of the input.

2. **Space Complexity**: Space complexity refers to the amount of memory or storage space required by an algorithm to perform its task based on the size of the input.


## Big O Notation
Big O Notation is the most fundamental tool to measure the cost of an algorithm. It describes the complexity of the code using algebraic terms.

1. **Constant:** The algorithm takes the same amount of time to run regardless of the size of its input.

2. **Logarithmic:** The algorithm's runtime grows logarithmically with the size of its input.

3. **Linear:** The algorithm's runtime grows linearly with the size of its input.

4. **Quadratic:** This means that the algorithm's performance increases quadratically as the input size 'n' grows. 

5. **Cubic:** This means that the algorithm's runtime or resource usage grows cubically as the input size 'n' increases. 

6. **Exponential:** This means that the algorithm's performance deteriorates significantly as the input size 'n' increases. 

7. **Factorial:** This is the most inefficient time complexity, where the algorithm's performance grows factorially with the input size 'n.' 
